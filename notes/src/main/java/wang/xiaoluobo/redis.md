# redis version 4.0.9
## redis持久化
1. RDB(Redis DataBase)  
指定的时间间隔持久化数据集创建的时间点快照

    1. RDB优点
        - RDB是一个非常紧凑的文件，Redis以单文件和时间点的方式表示你的数据集。RDB非常适合于备份数据。例如，你可能想要将最近24小时的数据，每隔1小时归档至你的RDB文件之中，并且还想要将最近30日的数据，每隔1日保存为一个RDB快照文件。当Redis发生灾难时，你就可以轻松地恢复不同版本的数据集。
        - RDB持久化非常适合于灾难恢复，它是一个结构紧凑的文件，既可以传输至较远的数据中心，也可以传输至Amazon S3的云主机（有可能会加密）。
        - RDB持久化会尽量提高Redis的性能，因为Redis的父进程只需要创建一个子进程就可以进行数据持久化了，所有的数据持久化工作都是由上述的子进程实现的。父进程从来不会执行磁盘I/O操作，或者其他类似的操作。
        - 相比起AOF持久化，当你的数据集较大时，如果Redis使用RDB持久化，那么它在重新启动时恢复数据集的速度会更快。
    2. RDB缺点
        - 当Redis意外停止工作时（例如，发生停电之后），如果你需要尽量减小数据丢失的可能性，那么RDB并不是一个很好的选择。你可以在产生RDB快照的地方配置不同的保存点（Save Point）。例如，可以在至少经过5分钟且对数据集有100次写入操作时，设置一个保存点（但是，你也可以设置多个保存点）。然而，你通常会每隔5分钟（或更长时间），就创建一个RDB快照。因此，当Redis由于意外关机而停止工作时，你可能会丢失最近几分钟之内的数据。
        - 如果要使用RDB持久化，那么Redis需要经常运行fork()函数，这样便能通过子进程将数据持久化保存在磁盘上。当数据集较大时，fork()函数可能会耗费较多的时间。如果数据集非常大，并且CPU性能不是很好，那么fork()函数可能会导致Redis在短时间内无法为客户端提供服务，这段时间长达若干毫秒，甚至会长达1秒。AOF也需要调用fork()函数，但是你可以调整Redis重写日志文件的频率，不用对Redis的耐用性作出任何折中。
        
2. AOF(Append-Only File)  
持久化会记录Redis服务器收到的每个写入操作，当Redis服务器重新启动时，这些写入操作就会被重新执行，这样便能重新建立原始数据集。
Redis会以一种只增的方式，将收到的写入命令记录在AOF文件之中，存储的数据格式和Redis协议自身的格式相同。当AOF文件变得太大时，
Redis会在后台重写日志文件。

    1. AOF优点
        - 当Redis使用AOF持久化时，它的耐用性会更好。你可以配置不同的fsync()调用策略：从不调用fsync()函数、每秒调用一次fsync()函数、每次查询调用一次fsync()函数。当使用默认的fsync()调用策略时，每秒写入的性能仍然非常不错（Redis会使用一个后台线程来调用fsync()函数，当没有任何fsync()函数正在运行时，主线程便会尝试执行写入操作。），你可能只会丢失1秒钟内写入的数据。
        - AOF日志是一种只增日志文件，所以不会有任何查找操作，即使发生停电事故，Redis也不会产生数据破坏的问题。如果由于某些原因（磁盘已满或其他原因）导致AOF日志文件的末尾有一条尚未完成的写入命令，那么你可以使用redis-check-aof工具轻松地修复这个问题。
        - 当AOF日志文件变得太大时，Redis能够在后台自动地重写这个日志文件。这种重写操作是非常安全的。当Redis持续向老日志文件追加日志时，它会创建一个全新的日志文件，这个新日志文件包含用于创建当前数据集的最小操作集，一旦这个新日志文件被创建完成，Redis便会切换至新日志文件，然后向新日志文件追加日志。
        - AOF日志文件包含所有操作的日志，每个操作会逐条记录在这个日志文件之内，这种格式易于理解和解析。你甚至可以轻松地导出一个AOF日志文件。例如，即使你使用FLUSHALL命令误删了所有的数据，如果此时Redis没有进行日志重写操作，那么你还可以挽救误删的数据，只需要停止Redis服务器，删除日志中的最后一条命令，然后再次重新启动Redis服务器即可。
    2. AOF缺点
        - 对于相同的数据集来说，AOF文件的尺寸通常要比同等的RDB文件更大。
        - AOF持久化的速度可能会比RDB持久化更慢，这取决于确切的fsync()函数调用策略。通常，当fsync()调用策略被设置为every second时，AOF持久化的性能仍然非常好；当禁用fsync()调用时，即使在高负载的情况下，AOF持久化的速度应当几乎和RDB持久化一样快。即使在海量写入负载的情况下，RDB仍然能够为最大延迟时间提供更多的保障。
        - 在过去，当我们使用特定的命令（例如，使用一些会造成阻塞的命令，诸如BRPOPLPUSH命令）时，可能会碰到一些罕见的bug，这些bug会导致Redis在重新载入AOF文件时，无法正确地将数据集恢复成先前保存的状态。我们已经在测试套件中进行了一些测试：首先，自动创建若干个随机的复杂数据集；然后，重新载入这些数据集；最后，检查数据集是否被正确恢复。虽然这种bug在AOF持久化中并不常见，但是相比之下，这种bug在RDB持久化中几乎不可能发生。下面将这一点解释的更清楚一些：Redis的AOF持久化会增量更新一个已有的日志文件，就像MySQL或MongoDB一样；而RDB持久化会反复地创建完整的数据快照，这样在概念上显得更加健壮。然而 —— （1）应当注意到，Redis每次重写AOF日志文件时，它会根据数据集包含的实际数据，重建AOF日志文件。相比起总是追加日志的AOF文件（或者，重写AOF日志文件时，读取的是老的AOF文件，而不是内存中的数据），上述方式对于这种bug的抵抗力更加强大。（2）目前，暂时还没有用户在实际应用中碰到AOF文件损坏的情况。
