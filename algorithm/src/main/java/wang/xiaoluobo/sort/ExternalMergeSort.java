package wang.xiaoluobo.sort;

/**
 * https://zh.wikipedia.org/zh-cn/%E5%A4%96%E6%8E%92%E5%BA%8F
 * https://www.jianshu.com/p/b8faa1affe17
 * <p>
 * 外部排序核心算法思想(多路归并算法思想)
 * (1)将数据进行切分，例如以100m或1g元素为1一组，将每一段数据分配到节点进行排序，切分的大小符合节点内存大小限制
 * (2)这样每个节点各自对分配数据进行排序，采用归并排序或快速排序皆可
 * (3)将每个排序好的节点按照归并算法整合到一个节点
 *
 * k路归并算法实现 —– 堆(PriorityQueue)
 * 其中第(1),(2)步实现较容易，重点在于如何将多个节点归并到一个节点，也就是k路归并。归并算法为不断比较各个节点的头元素，
 * 取最小值放入最终节点中，可是如何比较k个头结点, 逐个比较则效率较低，此时应该想到一个数据结构——堆！
 * 堆是一棵二叉树，具有以下特点：
 * 在二叉树上任何一个子节点都不大(或小于)于其父节点。
 * 必须是一棵完全的二叉树，即除了最后一层外，以上层数的节点都必须存在并且要集中在左侧。
 * 所以依据堆的特点，我们可以构造一棵最小二叉堆，使得头结点一定是最小值，于是构造一个大小为k的堆，先将k个节点的头元素插入到堆中，
 * 然后每次取出头结点，取出来的元素属于哪个子数组，再添加这个子数组的下一个元素进入堆中，来维护这个堆。
 * 一般在编码实现中无需重新构造堆结构，可直接使用库中对应的PriorityQueue优先队列，将k个头结点push进队列，然后pop出头结点，
 * 同时push进该头结点对应子数组的一个元素。以上就是算法核心，其中push、pop操作都是O(logk)
 *
 * 缓冲区
 * 每个节点的内存可以分别容纳数据，可是将所有节点归并到一个节点时，又回到了10G，不可能全放入内存，到底在内存中放入多少？
 * 其实只需将每个节点的最小值放入内存即可，例如上图中2，1，3，4放入内存，但是把最小值1拿掉之后需要补充一个元素，将外部内存的2拿到内存里来，
 * 可是外部内存可能在硬盘或网络，此过程相比内存操作会很慢，不断读取外部内存效率很低，所以采用缓存区，每次读取k个节点前部分数据到缓存区(几k或几M)
 *
 * @author wangyd
 * @date 2018/11/15
 */
public class ExternalMergeSort {

}
